#include "starter.h"

#ifdef C_STRUCT_MEM_ALIGN

// C++中空class(没有属性的class)的对象占1个字节
// C requires that a struct or union has at least one member
struct num {
	//TODO 心得： 小的数据类型写在最上面，大的数据类型写在最下面（节约空间）
	double a;	//8
	char b;		//1
	int c;		//4
	//char d;		//1
};
//TODO 内存对齐：不管是结构体，还是普通的变量，都存在内存对齐
//TODO 1.确定变量位置： 只能放在自己类型整数倍的内存地址上	 ====> 内存地址/占用字节=结果可以整除
int main() {
	printf("%zu\n", sizeof(struct num)); // 24字节

	//TODO 2.最后一个补位： 结构体的总大小，是最大类型的整数倍
	/*
	 _______ _______
	|___0___|___a___|
	|___1___|___a___|
	|___2___|___a___|
	|___3___|___a___|
	|___4___|___a___|
	|___5___|___a___|
	|___6___|___a___|
	|___7___|___a___|
	|___8___|___b___|
	|___9___|_______|
	|__10___|_______|
	|__11___|_______|
	|__12___|___c___|	4的整数倍
	|__13___|___c___|
	|__14___|___c___|
	|__15___|___c___|
	|__16___|___d___|	真实总大小：17个字节
	|__17___|_______|
	|__18___|_______|
	|__19___|_______|
	|__20___|_______|
	|__21___|_______|
	|__22___|_______|
	|__23___|_______|	对齐后总大小：24个字节
	*/

	//普通变量内存对齐
	int a = 10;
	int b = 10;
	printf("int a 地址除以4，余数为: %zu\n", (long long)&a % sizeof(int));
	printf("int b 地址除以4，余数为: %zu\n", (long long)&b % sizeof(int));
	printf("%zu\n", (long long)&a);
	printf("%zu\n", (long long)&b);


	//为什么要对齐
	//假设访问一个4字节的int,存放地址 0x1000
	/*
	地址： 0x1000 0x1001 0x1002 0x1003
	数据： [----------int x----------]
	CPU一次总线请求即可返回
	*/

	//假设 int y 放在地址 0x1001
	/*
	地址： 0x1000 0x1001 0x1002 0x1003 0x1004
	数据：        [----------int y----------]
	低3个字节在 0x1000~0x1003
	高1个字节在 0x1004~0x1007
	CPU无法一次性读取到完整数据。
	于是需要做两步：
		1.从0x1000取一块数据
		2.从0x1004再取一块
		3.CPU在内部拼接（shift + mask）合成正确的4字节

		多一次总线访问、多几条ALU指令处理拼接，性能降低
	*/
	return 0;
}

#endif // C_STRUCT_MEM_ALIGN